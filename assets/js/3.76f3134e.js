(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{40:function(t,a,e){t.exports=e.p+"assets/img/stack-heap.ac0c70b7.png"},41:function(t,a,e){t.exports=e.p+"assets/img/event-loop.c26f346a.png"},42:function(t,a,e){t.exports=e.p+"assets/img/hong-wei.c3f59522.jpeg"},53:function(t,a,e){"use strict";e.r(a);var r=e(0),s=Object(r.a)({},function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"堆和栈、event-loop、宏微任务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆和栈、event-loop、宏微任务","aria-hidden":"true"}},[t._v("#")]),t._v(" 堆和栈、Event loop、宏微任务")]),t._v(" "),r("h2",{attrs:{id:"数据类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据类型","aria-hidden":"true"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),r("p",[r("code",[t._v("js 有 undefined,null,bool,string,number,symbol 六种 数据类型")])]),t._v(" "),r("ul",[r("li",[t._v("虽然 typeof null 返回的值是 object,但是null不是对象，而是基本数据类型的一种")]),t._v(" "),r("li",[t._v("基本数据类型存储在栈内存，存储的是值")]),t._v(" "),r("li",[t._v("复杂数据类型的值存储在堆内存，地址（指向堆中的值）存储在栈内存。当我们把对象赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会变化。")])]),t._v(" "),r("h2",{attrs:{id:"堆和栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆和栈","aria-hidden":"true"}},[t._v("#")]),t._v(" 堆和栈")]),t._v(" "),r("ul",[r("li",[t._v("内存堆：这是内存分配发生的地方")]),t._v(" "),r("li",[t._v("调用栈：这是你的代码执行时的地方")])]),t._v(" "),r("p",[t._v("JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。")]),t._v(" "),r("p",[r("img",{attrs:{src:e(40),alt:"堆栈"}}),t._v("\n因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从栈中获取了该对象的内存指针，然后再从堆内存中取得我们需要的数据。")]),t._v(" "),r("h2",{attrs:{id:"event-loop"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#event-loop","aria-hidden":"true"}},[t._v("#")]),t._v(" Event loop")]),t._v(" "),r("ol",[r("li",[t._v("所有同步任务都在主线程上执行，形成一个执行栈")]),t._v(" "),r("li",[t._v("主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件")]),t._v(" "),r("li",[t._v("当执行栈中的所有同步任务执行完毕，系统就会读取任务队列,将队列中的事件放到执行栈中依次执行")]),t._v(" "),r("li",[t._v("不断重复以上步骤")])]),t._v(" "),r("p",[r("code",[t._v("执行栈：先进后出；")]),t._v(" "),r("code",[t._v("任务队列：先进先出；")]),t._v(" "),r("img",{attrs:{src:e(41),alt:"Event lop"}})]),t._v(" "),r("h2",{attrs:{id:"宏任务和微任务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务","aria-hidden":"true"}},[t._v("#")]),t._v(" 宏任务和微任务")]),t._v(" "),r("p",[r("code",[t._v("微任务和宏任务都是属于队列，而不是放在栈中")])]),t._v(" "),r("h3",{attrs:{id:"宏任务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#宏任务","aria-hidden":"true"}},[t._v("#")]),t._v(" 宏任务")]),t._v(" "),r("p",[t._v("可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。")]),t._v(" "),r("p",[t._v("浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程如下："),r("br"),t._v(" "),r("code",[t._v("(macro)task->渲染->(macro)task->...")])]),t._v(" "),r("h3",{attrs:{id:"微任务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#微任务","aria-hidden":"true"}},[t._v("#")]),t._v(" 微任务")]),t._v(" "),r("p",[t._v("microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。\n"),r("br")]),t._v(" "),r("p",[t._v("所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。\n"),r("br")]),t._v(" "),r("p",[r("code",[t._v("microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)")])]),t._v(" "),r("p",[t._v("完整的Event loop: "),r("br"),t._v(" "),r("img",{attrs:{src:e(42),alt:"Event lop"}})]),t._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考资料: 常见异步笔试题"),r("OutboundLink")],1)])])},[],!1,null,null,null);a.default=s.exports}}]);