# 拖拽

## 用 css 定位 + 鼠标事件实现拖拽

::: tip 原理

1. 鼠标摁下时`开始拖拽`
2. 记录摁下时的鼠标`开始位置` 和 `元素初始位置`
3. 移动后获取到鼠标的`新位置`
4. 用鼠标新位置 - 摁下时鼠标的开始位置 = `鼠标移动距离`
5. `元素当前位置` = 鼠标移动距离 + 元素初始位置
   :::

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      #box {
        position: absolute;
        left: 0;
        top: 0;
        z-index: 1;
        width: 100px;
        height: 100px;
        background-color: #fb3449;
      }
    </style>
  </head>

  <body>
    <div id="box"></div>

    <script>
      // 先写一个观察者 用于后续事件绑定
      class Event {
        constructor() {
          this.hanlers = {};
        }
        on(type, fn, once = false) {
          fn.once = once;
          if (this.hanlers[type]) {
            this.hanlers[type].push(fn);
            this.hanlers[type] = [...new Set(this.hanlers[type])];
          } else {
            this.hanlers[type] = [fn];
          }
        }
        off(type, fn) {
          if (this.hanlers[type]) {
            if (!fn) {
              this.hanlers[type] = [];
            } else {
              this.hanlers[type] = this.hanlers[type].filter(f => f !== fn);
            }
          }
        }
        trigger(type, e = {}, _this = this) {
          if (this.hanlers[type]) {
            this.hanlers[type].forEach(fn => {
              fn.call(_this, e);
              if (fn.once) this.off(type, fn);
            });
          }
        }
        once(type, fn) {
          this.on(type, fn, true);
        }
      }

      class Drag extends Event {
        constructor(el) {
          super();
          // 要拖拽的目标元素
          this.el = el;
          // 元素自身初始为
          this.domStartOffset = {};
          // 鼠标按下时位置
          this.startPoint = {};
          // 元素拖拽过程中实时定位
          this.position = {};
          // 绑定this，用于拖拽结束之后解绑事件
          this.bindMove = this.move.bind(this);
          this.bindEnd = this.end.bind(this);
          this.el.addEventListener("mousedown", e => {
            this.start(e);
            document.addEventListener("mousemove", this.bindMove);
            document.addEventListener("mouseup", this.bindEnd);
          });
        }

        start(e) {
          const { el } = this;
          this.domStartOffset = {
            x: el.offsetLeft,
            y: el.offsetTop
          };
          this.startPoint = {
            x: e.clientX,
            y: e.clientY
          };
          this.trigger("start", e, this.el);
        }

        move(e) {
          let { el, domStartOffset, startPoint } = this;
          const nowPoint = {
            x: e.clientX,
            y: e.clientY
          };
          this.position = {
            x: nowPoint.x - startPoint.x + domStartOffset.x,
            y: nowPoint.y - startPoint.y + domStartOffset.y
          };
          this.el.style.left = this.position.x + "px";
          this.el.style.top = this.position.y + "px";
        }
        end(e) {
          document.removeEventListener("mousemove", this.bindMove);
          document.removeEventListener("mouseup", this.bindEnd);
          this.trigger("end", e, this.el);
        }
      }
      const box = document.querySelector("#box");
      const drag = new Drag(box);

      // 绑定回调
      drag.on("start", function(e) {
        this.style.background = "yellow";
      });
      drag.on("end", function(e) {
        this.style.background = "red";
      });
    </script>
  </body>
</html>
```
