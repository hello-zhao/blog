# 堆和栈、Event loop、宏微任务

## 数据类型

` js 有 undefined,null,bool,string,number,symbol 六种 数据类型 `
* 虽然 typeof null 返回的值是 object,但是null不是对象，而是基本数据类型的一种
* 基本数据类型存储在栈内存，存储的是值
* 复杂数据类型的值存储在堆内存，地址（指向堆中的值）存储在栈内存。当我们把对象赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个对象改变时，另一个对象也会变化。

## 堆和栈
+ 内存堆：这是内存分配发生的地方
+ 调用栈：这是你的代码执行时的地方

JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。

<img :src="$withBase('/stack-heap.png')">
因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从栈中获取了该对象的内存指针，然后再从堆内存中取得我们需要的数据。

## Event loop
1. 所有同步任务都在主线程上执行，形成一个执行栈
2. 主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件
3. 当执行栈中的所有同步任务执行完毕，系统就会读取任务队列,将队列中的事件放到执行栈中依次执行
4. 不断重复以上步骤

` 执行栈：先进后出； `
` 任务队列：先进先出； `
<img :src="$withBase('/event-loop.png')">

## 宏任务和微任务
` 微任务和宏任务都是属于队列，而不是放在栈中 `

### 宏任务
可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。

浏览器为了能够使得JS内部(macro)task与DOM任务能够有序的执行，会在一个(macro)task执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程如下：<br>
` (macro)task->渲染->(macro)task->... `

### 微任务

microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前。
<br>

所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。
<br>

` microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) `

完整的Event loop: <br>
<img :src="$withBase('/hong-wei.jpeg')">

[参考资料: 常见异步笔试题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7)
