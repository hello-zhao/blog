# 构造函数原型继承

::: tip
es5 没有类只能利用构造函数和原型链模拟类
`es6 实现了类`
:::

**ES6中的class和ES5的类有什么区别？**

+ ES6 class 内部所有定义的方法都是不可枚举的;
+ ES6 class 必须使用 new 调用;
+ ES6 class 不存在变量提升;
+ ES6 class 默认即是严格模式;
+ ES6 class 子类必须在父类的构造函数中调用super()，这样才有this对象;ES5中类继承的关系是相反的，先有子类的this，然后用父类的方法应用在this上。

**创建类**

```js
function Parent(name, age) {
  // 实例属性绑定
  this.name = name;
  this.age = age;
}
// 构造函数原型, 实例共享
Parent.prototype.sayName = function() {
  console.log(this.name);
};
Parent.prototype.sayAge = function() {
  console.log(this.age);
};
const tom = new Parent("tom", 99);
console.log(tom);

/* Parent {name: "tom", age: 99}
   age: 99                             // 实例属性
   name: "tom"
   __proto__:                          // 实例的原型链指向构造函数的原型
    sayAge: ƒ ()                       // 原型上的方法
    sayName: ƒ ()
    constructor: ƒ Parent(name, age)   // 构造函数
    __proto__: Object */
```

## js 中的继承

::: tip

- 构造函数的继承
- 原型的继承
  - 拷贝继承
    - 深拷贝
    - 浅拷贝
  - 原型链继承
:::

### 构造函数继承

```js
function Child(name, age, skill) {
  // 寄生
  Parent.call(this, name, age);
  this.skill = skill;
}
const tom2 = new Child("tom", 48, "吃");
console.log(tom2);

// 原型中的属性、方法未继承
/* Child {name: "tom", age: 99, skill: "吃"}
   age: 99
   name: "tom"
   skill: "吃"
   __proto__:
    constructor: ƒ Child(name, age, skill)
    __proto__: Object */
```

### 原型继承

`原型链：当我们在调用对象的属性或方法时，如果对象没有这个方法或属性 就去原型链里找`

```js
function extend(Child, Parent) {
  var F = function() {};
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  // 设置正确的构造函数指向
  Child.prototype.constructor = Child;
}
// 利用空对象做中介进行原型链继承  缺点：prototype属性等于数组或另一个对象，子对象获得的只是一个内存地址，父对象存在被篡改的可能。
extend(Child, Parent);

const tom3 = new Child("tom", 48, "吃");
console.log(tom3);
/* Child {name: "tom", age: 48, skill: "吃"}
   age: 48
   name: "tom"
   skill: "吃"
   __proto__: Parent          // Child 继承 Person
    constructor: ƒ Child(name, age, skill)
    __proto__:
      sayAge: ƒ ()            // 原型上方法也继承了
      sayName: ƒ ()
      constructor: ƒ Parent(name, age)
      __proto__: Object */
 =================================================

// 浅拷贝继承 缺点：只拷贝一层, 父子的原型链没有继承关系， prototype属性等于数组或另一个对象，子对象获得的只是一个内存地址，父对象存在被篡改的可能。
for (let key in Parent.prototype) {
  Child.prototype[key] = Parent.prototype[key];
}

const tom4 = new Child('tom', 48, '吃');
console.log(tom4);
/* Child {name: "tom", age: 48, skill: "吃"}
   age: 48
   name: "tom"
   skill: "吃"
   __proto__:
    sayAge: ƒ ()
    sayName: ƒ ()
    constructor: ƒ Child(name, age, skill)
    __proto__: Object */
=================================================

// 深拷贝 递归调用浅拷贝 缺点：父子的原型链没有继承关系
function deepCopy(parent, child = {}) {
  for (var key in parent) {
    if (typeof parent[key] === "object") {
      child[key] = Array.isArray(parent[key]) ? [] : {};
      deepCopy(parent[key], child[key]);
    } else {
      child[key] = parent[key];
    }
  }

  return child;
}

Child.prototype = deepCopy(Parent.prototype);

const tom5 = new Child('tom5', 48, '吃');
console.log(tom5);

/* Child {name: "tom5", age: 48, skill: "吃"}
   age: 48
   name: "tom5"
   skill: "吃"
   __proto__:
    sayAge: ƒ ()
    sayName: ƒ ()
    __proto__: Object */
```


```js
// 递归二
function deepClone(obj) { //递归拷贝
  if(obj === null) return null; //null 的情况
  if(obj instanceof RegExp) return new RegExp(obj);
  if(obj instanceof Date) return new Date(obj);
  if(typeof obj !== 'object') {
      //如果不是复杂数据类型，直接返回
      return obj;
  }
  /**
   * 如果obj是数组，那么 obj.constructor 是 [Function: Array]
   * 如果obj是对象，那么 obj.constructor 是 [Function: Object]
   */
  let t = new obj.constructor();
  for(let key in obj) {
      //如果 obj[key] 是复杂数据类型，递归
      t[key] = deepClone(obj[key]);
  }
  return t;
}
```
