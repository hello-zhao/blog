# 算法

## 递归应用

递归渲染多级菜单

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      li {
        line-height: 30px;
      }
    </style>
  </head>

  <body>
    <ul id="list"></ul>
  </body>
</html>
<script>
  let datas = [
    {
      name: "js",
      children: [
        {
          name: "es6",
          children: [
            {
              name: "解构赋值"
            },
            {
              name: "Proxy"
            },
            {
              name: "Promise"
            }
          ]
        },
        {
          name: "css",
          children: [
            {
              name: "布局"
            },
            {
              name: "过渡、动画"
            }
          ]
        }
      ]
    }
  ];

  let ulElement = document.querySelector("#list");

  ulElement.innerHTML = createHTML(datas);

  function createHTML(items, level = 0) {
    return items
      .map(item => {
        let s = "&nbsp;".repeat(4 * level);

        let str = `
                <li>${s} ${level} - ${item.name}</li>
            `;

        if (Array.isArray(item.children)) {
          str += createHTML(item.children, level + 1);
        }

        return str;
      })
      .join("");
  }
</script>
```

## 冒泡排序
`用 for 循环`

```js
let arr = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8];

for (let j = 0; j < arr.length - 1; j++) {
  let isOk = true;

  for (let i = 0; i < arr.length - 1 - j; i++) {
    let a = arr[i];
    let b = arr[i + 1];
    if (a > b) {
      [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
      isOk = false;
    }
  }

  if (isOk) {
    break;
  }
}

console.log(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
`源生数组方法`

``` js
let arr = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8];

arr.sort( (a, b)  => a - b);

console.log(arr); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

## 快速排序

::: tip 排序原理
+ 在数据集之中，选择一个元素作为"基准"（pivot）
+ 所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。
+ 对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
:::

``` js
let arr = [6, 1, 2, 7, 9, 3, 4, 5, 10, 8];

function quickSortRecursion (arr) {
  if (!arr || arr.length < 2) return arr;
  const pivot = arr.pop();
  let left = arr.filter(item => item < pivot);
  let right = arr.filter(item => item >= pivot);
  return quickSortRecursion(left).concat([pivot], quickSortRecursion(right));
}

console.log(quickSortRecursion(arr)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// 链式调用
const qsort = arr => arr.length <= 1? arr:
    qsort(arr.filter(x => x < arr[0]))
    .concat(arr.filter(x => x == arr[0]))
    .concat(qsort(arr.filter(x => x > arr[0])));
```
