# 防抖和节流
防抖和节流的作用都是防止函数多次调用。区别在于，假设一直触发这个函数，且每次触发函数的间隔小于设置的时间，防抖的情况下只会调用一次，而节流的情况会每隔一定时间调用一次函数。

:::tip
防抖(debounce): n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间
:::

```js

/*
* @param {Function} func 传入需要防抖的函数
* @param {Number} [wait=0] 需要延迟的毫秒数
* @param {Boolean} [immediate=true] 初始时是否需要立即执行
*/
function debounce(func, wait = 0, immediate = true) {
  let timeout, context, args;
  // 延迟执行函数
  const later = () => setTimeout(() => {
    // 延迟函数执行完毕，清空定时器
    timeout = null;
    // 延迟执行的情况下，函数会在延迟函数中执行
    // 使用到之前缓存的参数和上下文
    if (!immediate) {
      func.apply(context, args);
      context = args = null;
    }
  }, wait);
  let debounced = function (...params) {
    if (!timeout) {
      timeout = later();
      if (immediate) {
        //初始立即执行
        func.apply(this, params);
        immediate = false;
      } else {
        //闭包
        context = this;
        args = params;
      }
    } else {
      clearTimeout(timeout);
      timeout = later();
    }
  }
  debounced.cancel = function () {
    clearTimeout(timeout);
    timeout = null;
  };
  return debounced;
};
```

:::tip
节流(throttle): 高频事件在规定时间内只会执行一次，执行一次后，只有大于设定的执行周期后才会执行第二次。
:::

```js
/*
* @param {Function} func 传入需要节流的函数
* @param {number} [wait=0] 需要延迟的毫秒数
*/
function throttle(func, wait) {
  let timeout, context, args, result;
  let previous = 0;

  const later = function () {
    previous = Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  const throttled = function (...params) {
    const now = Date.now();
    const remaining = wait - (now - previous);
    context = this;
    args = params;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
          clearTimeout(timeout);
          timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout) {
      // 判断是否设置了定时器
      timeout = setTimeout(later, remaining);
    }
    return result;
  };

  throttled.cancel = function () {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
  };

  return throttled;
};
```
